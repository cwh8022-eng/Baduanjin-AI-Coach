<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å…«æ®µéŒ¦å‹•ä½œè¾¨è­˜ï¼‹è©•åˆ†ç³»çµ±</title>

  <!-- èˆ‡ tmPose æœ€ç›¸å®¹ -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/pose@0.8/dist/teachablemachine-pose.min.js"></script>

  <style>
    :root { --w: 980px; }
    body { font-family: Arial, "Noto Sans TC", system-ui; background:#f3f5f8; padding:22px 14px 40px; color:#1f2937; }
    h1 { text-align:center; margin:0 0 10px; font-weight:700; }
    .hint { text-align:center; color:#6b7280; margin:6px 0 12px }
    .wrap { width:min(var(--w), 96vw); margin:0 auto; }
    .row-btns { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:10px 0 14px; }
    button { padding:10px 16px; border:0; border-radius:10px; background:#0ea5e9; color:#fff; cursor:pointer; font-size:16px; box-shadow:0 4px 14px rgba(14,165,233,.25); }
    button:hover { filter:brightness(1.05) }
    .stage { display:grid; grid-template-columns: 440px 1fr; gap:18px; align-items:flex-start; }
    @media (max-width:980px){ .stage{ grid-template-columns: 1fr } }
    canvas { width:min(420px,96vw); height:auto; border-radius:12px; border:2px solid #334155; background:#000; }

    /* Scoreboard */
    .score { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:12px 14px; margin-bottom:12px; display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .pill { background:#eef2ff; color:#3730a3; padding:6px 10px; border-radius:999px; font-weight:700; }
    .pill strong{ font-variant-numeric: tabular-nums }
    .cfg { color:#6b7280; font-size:14px }
    .cfg input { width:64px; padding:4px 6px; border-radius:8px; border:1px solid #cbd5e1; margin-left:4px }

    /* Bars panel */
    .panel { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:12px 14px; }
    .title { font-size:14px; color:#6b7280; margin:0 0 8px }
    .row { display:grid; grid-template-columns: 185px 1fr; gap:12px; align-items:center; margin:10px 0; }
    .name { font-weight:700; color:#374151; display:flex; align-items:center; gap:8px }
    .chips { display:inline-flex; gap:6px; margin-left:6px }
    .chip { background:#e2e8f0; color:#0f172a; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:700 }
    .track { position:relative; background:#e5e7eb; border-radius:999px; overflow:hidden; height:22px; box-shadow: inset 0 1px 1px rgba(0,0,0,.06); }
    .bar { height:100%; width:0%; background:linear-gradient(90deg,#34d399,#10b981); color:#fff; line-height:22px; text-align:right; padding-right:8px; font-size:12px; font-weight:600; transition:width .12s linear; }
    .cls { position:absolute; right:8px; top:-18px; font-size:11px; color:#6b7280; }
    .flash { animation:flash .5s ease }
    @keyframes flash{ from{ box-shadow:0 0 0 0 rgba(16,185,129,.8)} to{ box-shadow:0 0 0 12px rgba(16,185,129,0)}}

    #msg{white-space:pre-line;font-weight:700;color:#c0392b;text-align:center;margin:8px 0 12px}
    .ok{ color:#065f46 }
  </style>
</head>
<body>
  <h1>å…«æ®µéŒ¦å‹•ä½œè¾¨è­˜ï¼‹è©•åˆ†</h1>
  <div class="hint">è«‹ä»¥ HTTPS/localhost é–‹å•Ÿä¸¦å…è¨±æ”å½±æ©Ÿï¼›éª¨æ¶/æ¨è«–æºåŒç”¨ <code>webcam.canvas</code>ï¼Œä¸æœƒåç§»ã€‚</div>

  <div class="wrap">
    <div class="row-btns">
      <button id="btnStart">â–¶ï¸ é–‹å§‹ç·´ç¿’</button>
      <button id="btnReset">ğŸ§¹ é‡ç½®è©•åˆ†</button>
    </div>

    <div class="score">
      <div class="pill">ç¸½åˆ†ï¼š<strong id="totalScore">0</strong> åˆ†</div>
      <div class="pill">æ™‚é–“ï¼š<strong id="timer">00:00</strong></div>
      <div class="pill">ç•¶å‰ï¼š<strong id="currentMove">â€”</strong></div>
      <div class="cfg">
        é–€æª»ï¼ˆæ©Ÿç‡ 0~1ï¼‰<input id="thres" type="number" step="0.05" min="0.5" max="0.95" value="0.75">
        æœ€çŸ­ç¶­æŒç§’æ•¸<input id="hold" type="number" step="0.5" min="0.5" max="5" value="2">
        å†·å»ç§’æ•¸<input id="cool" type="number" step="0.1" min="0.2" max="3" value="0.8">
      </div>
    </div>

    <div id="msg"></div>

    <div class="stage">
      <canvas id="canvas" width="400" height="400"></canvas>

      <div class="panel">
        <p class="title">å³æ™‚è¾¨è­˜ï¼ˆå›ºå®šå…«å¼é †åºï¼‰</p>
        <div id="bars"></div>
      </div>
    </div>
  </div>

<script>
(async function(){
  // 8 å¼ï¼ˆé¡¯ç¤ºé †åºï¼‰ï¼Œè«‹ç¢ºä¿èˆ‡ metadata.json labels å°å¾—ä¸Šï¼ˆç”¨ä¸‹æ–¹å°æ˜ è¦å‰‡è‡ªå‹•é…å°ï¼‰
  const TARGETS = [
    { key: 'D1', name: 'é›™æ‰‹æ‰˜å¤©ç†ä¸‰ç„¦' },
    { key: 'D2', name: 'å·¦å³é–‹å¼“ä¼¼å°„éµ°' },
    { key: 'D3', name: 'èª¿ç†è„¾èƒƒé ˆå–®èˆ‰' },
    { key: 'D4', name: 'äº”å‹ä¸ƒå‚·å¾€å¾Œç§' },
    { key: 'D5', name: 'æ–é ­æ“ºå°¾å»å¿ƒç«' },
    { key: 'D6', name: 'å…©æ‰‹æ”€è¶³å›ºè…è…°' },
    { key: 'D7', name: 'æ”¢æ‹³æ€’ç›®å¢æ°£åŠ›' },
    { key: 'D8', name: 'èƒŒå¾Œä¸ƒé¡›ç™¾ç—…æ¶ˆ' }
  ];

  // è‡ªå‹•å°æ‡‰ metadata è£¡çš„ class åç¨±ï¼ˆå®¹éŒ¯ï¼šç©ºç™½/ã€Œé›•â†”éµ°ã€/æ¨™é»ï¼‰
  const MAP_RULES = [
    { token:'é›™æ‰‹æ‰˜å¤©', k:'D1' }, { token:'æ‰˜å¤©', k:'D1' },
    { token:'é–‹å¼“', k:'D2' }, { token:'å°„é›•', k:'D2' }, { token:'å°„éµ°', k:'D2' },
    { token:'å–®èˆ‰', k:'D3' }, { token:'è„¾èƒƒ', k:'D3' },
    { token:'å¾€å¾Œç§', k:'D4' }, { token:'ä¸ƒå‚·', k:'D4' },
    { token:'æ“ºå°¾', k:'D5' }, { token:'å»å¿ƒç«', k:'D5' },
    { token:'æ”€è¶³', k:'D6' }, { token:'è…è…°', k:'D6' },
    { token:'æ”¢æ‹³', k:'D7' }, { token:'å¢æ°£åŠ›', k:'D7' },
    { token:'ä¸ƒé¡›', k:'D8' }, { token:'ç™¾ç—…æ¶ˆ', k:'D8' }
  ];
  const norm = s => (s||'').replace(/\s+/g,'').replace(/æ­£ç¢º/g,'').replace(/[()ï¼ˆï¼‰\[\]ã€ã€‘ï¼š:ï¼Œ,ã€‚.\-_/]/g,'').replace(/é›•/g,'éµ°').toLowerCase();

  const modelURL    = './model.json';
  const metadataURL = './metadata.json';
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const msg = document.getElementById('msg');
  const barsEl = document.getElementById('bars');

  const $ = id=>document.getElementById(id);
  const fmt = s=> s.toString().padStart(2,'0');

  const SIZE = 400;                  // èˆ‡ webcamã€canvas ä¸€è‡´ï¼ˆé—œéµï¼‰
  const alpha = 0.35;                // æ©Ÿç‡å¹³æ»‘ä¿‚æ•¸
  let model, webcam, indexMap=null, classNames=[];
  let smooth = Object.fromEntries(TARGETS.map(t=>[t.key,0]));
  let reps   = Object.fromEntries(TARGETS.map(t=>[t.key,0]));
  let score  = Object.fromEntries(TARGETS.map(t=>[t.key,0]));
  let totalScore = 0;

  // è©•åˆ†ç‹€æ…‹
  let currentKey = null;
  let holdStart  = 0;
  let holdSum    = 0;
  let holdFrames = 0;
  let cooldownUntil = 0;
  let sessionStart = 0;
  let running = false;

  // UIï¼šå»ºç«‹å…«æ¢
  function buildBars(labels){
    barsEl.innerHTML='';
    TARGETS.forEach((t,i)=>{
      const row = document.createElement('div'); row.className='row'; row.id=`row-${t.key}`;
      const name = document.createElement('div'); name.className='name';
      name.innerHTML = `${i+1}. ${t.name} <span class="chips"><span class="chip" id="rep-${t.key}">0 æ¬¡</span><span class="chip" id="sc-${t.key}">0 åˆ†</span></span>`;
      const track = document.createElement('div'); track.className='track';
      const bar = document.createElement('div'); bar.className='bar'; bar.id=`bar-${t.key}`; bar.textContent='0.0%';
      const cls = document.createElement('div'); cls.className='cls'; cls.id=`cls-${t.key}`; cls.textContent = (indexMap && indexMap[t.key]>=0 && labels[indexMap[t.key]]) ? labels[indexMap[t.key]] : 'ï¼ˆæœªå°æ‡‰ï¼‰';
      track.appendChild(bar); track.appendChild(cls);
      row.appendChild(name); row.appendChild(track);
      barsEl.appendChild(row);
    });
  }

  function buildIndexMap(labels){
    const map = {}; TARGETS.forEach(t=>map[t.key]=-1);
    labels.forEach((name, idx)=>{
      const n = norm(name);
      for(const r of MAP_RULES){ if(n.includes(r.token) && map[r.k]===-1){ map[r.k]=idx; break; } }
      for(let i=1;i<=8;i++){ if(map['D'+i]===-1 && n.includes('d'+i)) map['D'+i]=idx; }
    });
    return map;
  }

  function info(text, ok=false){ msg.style.color = ok ? '#065f46' : '#c0392b'; msg.textContent = text; }

  function updateCounters(){
    TARGETS.forEach(t=>{
      $('rep-'+t.key).textContent = `${reps[t.key]} æ¬¡`;
      $('sc-'+t.key).textContent  = `${score[t.key]} åˆ†`;
    });
    $('totalScore').textContent = totalScore;
  }

  function flashRow(key){
    const row = $('row-'+key);
    if(!row) return;
    row.classList.remove('flash'); // é‡æ”¾å‹•ç•«
    void row.offsetWidth;
    row.classList.add('flash');
  }

  function tickTimer(){
    if(!running) return;
    const sec = Math.max(0, Math.round((performance.now()-sessionStart)/1000));
    $('timer').textContent = `${fmt(Math.floor(sec/60))}:${fmt(sec%60)}`;
    requestAnimationFrame(tickTimer);
  }

  $('btnReset').onclick = ()=>{
    reps   = Object.fromEntries(TARGETS.map(t=>[t.key,0]));
    score  = Object.fromEntries(TARGETS.map(t=>[t.key,0]));
    totalScore = 0;
    currentKey = null; holdStart=0; holdSum=0; holdFrames=0; cooldownUntil=0;
    updateCounters();
    info('å·²é‡ç½®è©•åˆ†èˆ‡æ¬¡æ•¸', true);
  };

  $('btnStart').onclick = async ()=>{
    try{
      info('');
      // 1) è¼‰å…¥æ¨¡å‹ã€labels å°æ˜ 
      model = await tmPose.load(modelURL, metadataURL);
      let labels=[];
      try{
        const meta = await fetch(metadataURL,{cache:'no-store'}).then(r=>r.json());
        const raw = meta.labels || meta.classes || [];
        labels = raw.map(x => (x && x.label) ? x.label : (typeof x==='string' ? x : ''));
      }catch(_){}
      indexMap = buildIndexMap(labels);
      classNames = labels.slice();
      buildBars(classNames);

      // 2) å•Ÿç›¸æ©Ÿï¼ˆflip=true ç”± tmPose è™•ç†é¡åƒï¼‰ï¼† å°ºå¯¸ä¸€è‡´
      webcam = new tmPose.Webcam(SIZE, SIZE, true);
      await webcam.setup();
      await webcam.play();
      canvas.width = SIZE; canvas.height = SIZE;

      // 3) é–‹å§‹è¿´åœˆï¼†è¨ˆæ™‚
      running = true;
      sessionStart = performance.now();
      requestAnimationFrame(tickTimer);
      requestAnimationFrame(loop);
      info('âœ… å•Ÿå‹•æˆåŠŸï¼', true);
    }catch(e){
      info('âŒ ç„¡æ³•å•Ÿå‹•ï¼š\n' + (e.message || e.toString()));
      console.error(e);
    }
  };

  async function loop(){
    if(!running) return;
    webcam.update();
    await predict();
    requestAnimationFrame(loop);
  }

  async function predict(){
    // ä»¥ webcam.canvas ç‚ºå”¯ä¸€ä¾†æºåšæ¨è«–èˆ‡ç¹ªåœ–ï¼ˆé¿å…åº§æ¨™ä¸ä¸€è‡´ï¼‰
    const { pose, posenetOutput } = await model.estimatePose(webcam.canvas);
    const preds = await model.predict(posenetOutput);

    // å»ºç«‹ç›®å‰ 8 å¼çš„æ©Ÿç‡ mapï¼ˆå–å°æ˜  indexï¼Œç¼ºçš„çµ¦ 0ï¼‰
    const rawProb = {};
    TARGETS.forEach(t=>{
      const idx = indexMap ? indexMap[t.key] : -1;
      rawProb[t.key] = (idx>=0 && preds[idx]) ? (preds[idx].probability || 0) : 0;
    });

    // å¹³æ»‘èˆ‡æ¢æ›´æ–°
    let topKey = TARGETS[0].key, topVal = -1;
    TARGETS.forEach(t=>{
      const v = rawProb[t.key];
      smooth[t.key] = alpha * v + (1-alpha) * smooth[t.key];
      const pct = (smooth[t.key]*100).toFixed(1) + '%';
      const bar = $('bar-'+t.key);
      if(bar){ bar.style.width = pct; bar.textContent = pct; }
      if(smooth[t.key] > topVal){ topVal = smooth[t.key]; topKey = t.key; }
    });

    // ç¹ªå½±åƒèˆ‡éª¨æ¶ï¼ˆç­‰æ¯”åˆ°ç•«å¸ƒï¼‰
    ctx.drawImage(webcam.canvas, 0, 0, ctx.canvas.width, ctx.canvas.height);
    if(pose){
      tmPose.drawKeypoints(pose.keypoints, 0.5, ctx);
      tmPose.drawSkeleton(pose.keypoints, 0.5, ctx);
    }

    // é¡¯ç¤ºç•¶å‰æœ€é«˜é¡åˆ¥
    const humanName = TARGETS.find(x=>x.key===topKey)?.name || 'â€”';
    $('currentMove').textContent = `${humanName}ï¼ˆ${(topVal*100).toFixed(0)}%ï¼‰`;

    // === è©•åˆ†åˆ¤å®š ===
    const threshold = Math.max(0.5, Math.min(0.95, parseFloat($('thres').value)||0.75));
    const minHoldMs = Math.max(500, Math.min(5000, (parseFloat($('hold').value)||2)*1000));
    const cooldownMs= Math.max(200, Math.min(3000, (parseFloat($('cool').value)||0.8)*1000));

    const now = performance.now();
    if(now < cooldownUntil){
      // å†·å»ä¸­ï¼šç¶­æŒç­‰å¾…
      return;
    }

    if(topVal >= threshold){
      if(currentKey !== topKey){
        // æ›æ–°å‹•ä½œï¼šé–‹å§‹è¨ˆæ™‚
        currentKey = topKey;
        holdStart = now;
        holdSum = 0; holdFrames = 0;
      }
      // ç´¯ç©ç©©å®šåº¦
      holdSum += topVal; holdFrames++;
      const held = now - holdStart;

      if(held >= minHoldMs){
        // å®Œæˆä¸€æ¬¡ï¼Œçµ¦åˆ†
        const avg = holdSum / Math.max(1, holdFrames);     // å¹³å‡ç©©å®šåº¦
        const secs = held/1000;
        const points = Math.max(1, Math.round(secs * 10 * Math.max(0.5, avg))); // æ¯ç§’æœ€é«˜ ~10åˆ†ï¼Œä¾ç©©å®šåº¦åŠ æ¬Š
        reps[currentKey]  += 1;
        score[currentKey] += points;
        totalScore        += points;

        // UI æ›´æ–°èˆ‡ç‰¹æ•ˆ
        updateCounters();
        flashRow(currentKey);

        // é€²å…¥å†·å»ï¼Œé¿å…é€£çºŒçˆ†åˆ†ï¼›é‡ç½®æš«å­˜
        cooldownUntil = now + cooldownMs;
        currentKey = null; holdStart=0; holdSum=0; holdFrames=0;
      }
    }else{
      // ä½æ–¼é–€æª»ï¼šé‡ç½®ç­‰å¾…
      currentKey = null; holdStart=0; holdSum=0; holdFrames=0;
    }
  }
})();
</script>
</body>
</html>
