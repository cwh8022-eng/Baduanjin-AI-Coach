<script>
// ==========（可調參數）==========
const SIZE = 400;
const EMA_ALPHA = 0.35;         // 單幀指數平滑
const WINDOW = 12;              // 滑動視窗幀數（約 0.4s~0.6s 視影片 fps）
const MARGIN = 0.20;            // Top-1 與 Top-2 最小差距，避免混淆
const FALLBACK_THRESH = 0.80;   // UI 門檻輸入的預設值

// 針對每一式給「最低信心門檻」（可依你模型調整）
const PER_CLASS_THRESH = {
  D1: 0.80, D2: 0.85, D3: 0.80, D4: 0.80,
  D5: 0.82, D6: 0.82, D7: 0.85, D8: 0.80
};

// ==========（狀態）==========
let model, indexMap=null, classNames=[], running=false;
let smooth={},  // EMA 平滑
    ring=[],    // 滑動視窗：存每幀的平滑後機率
    done={},    // 每式是否已完成
    score={},   // 每式分數（100/0）
    totalAvg=0; // 八式平均

let currentKey=null, holdStart=0, holdSum=0, holdFrames=0, cooldownUntil=0;
let sessionStart=0;

const cv = document.getElementById('view');
const ctx = cv.getContext('2d');
const vid = document.getElementById('video');
const prog = document.getElementById('prog');
const ts = document.getElementById('ts');
const $ = id=>document.getElementById(id);
const pad2 = n=> n.toString().padStart(2,'0');
const fmt  = s=> `${pad2((s/60)|0)}:${pad2((s%60)|0)}`;

// 你原本的八式 & 對應規則請保留（略）……
// const TARGETS = [...];  const MAP_RULES = [...]; const norm = ...

function info(text, ok=false){ const m=$('msg'); m.style.color = ok?'#065f46':'#c0392b'; m.textContent = text; }
function flashRow(key){ const r=$('row-'+key); if(!r) return; r.classList.remove('flash'); void r.offsetWidth; r.classList.add('flash'); }

// 重新計算總分（八式平均）
function recalcTotal(){
  const sum = TARGETS.reduce((s,t)=> s + (score[t.key]||0), 0);
  totalAvg = Math.round(sum / TARGETS.length);
  $('totalScore').textContent = totalAvg;
}

// UI 初始化用（請保留你原本的 buildBars）
function resetScores(){
  smooth = Object.fromEntries(TARGETS.map(t=>[t.key,0]));
  ring = [];
  done   = Object.fromEntries(TARGETS.map(t=>[t.key,false]));
  score  = Object.fromEntries(TARGETS.map(t=>[t.key,0]));
  totalAvg = 0;
  TARGETS.forEach(t=>{
    $('status-'+t.key).textContent = '未完成';
    $('sc-'+t.key).textContent = '0';
    const row = $('row-'+t.key); row && row.classList.remove('flash');
    const bar = $('bar-'+t.key); if(bar){ bar.style.width='0%'; bar.textContent='0.0%'; }
  });
  $('totalScore').textContent = '0';
}

// 載入模型（保留你的 ensureModel，其內呼叫 buildBars(...) 並 resetScores()）
async function ensureModel(){
  if (model) return;
  model = await tmPose.load('./model.json','./metadata.json');
  let labels=[];
  try{
    const meta = await fetch('./metadata.json',{cache:'no-store'}).then(r=>r.json());
    const raw  = meta.labels || meta.classes || [];
    labels = raw.map(x => (x && x.label) ? x.label : (typeof x==='string' ? x : ''));
  }catch(_){}
  indexMap = buildIndexMap(labels);     // 你原本的函式
  classNames = labels.slice();
  buildBars(classNames);                // 你原本的函式：渲染 8 條
  resetScores();
  info('模型就緒：請選擇影片開始分析', true);
}

// ========== 核心：每幀處理（影片畫到 400x400 → 推論 → 多重穩定化） ==========
async function stepWithSource(sourceCanvas){
  const { pose, posenetOutput } = await model.estimatePose(sourceCanvas);
  const preds = await model.predict(posenetOutput);

  // 顯示畫面 + 骨架（同一張 sourceCanvas，座標不飄）
  ctx.drawImage(sourceCanvas, 0, 0, cv.width, cv.height);
  if(pose){ tmPose.drawKeypoints(pose.keypoints, 0.5, ctx); tmPose.drawSkeleton(pose.keypoints, 0.5, ctx); }

  // 取 8 類機率（缺的給 0）
  const rawProb = {};
  TARGETS.forEach(t=>{
    const idx = indexMap ? indexMap[t.key] : -1;
    rawProb[t.key] = (idx>=0 && preds[idx]) ? (preds[idx].probability || 0) : 0;
  });

  // 1) EMA 單幀平滑
  TARGETS.forEach(t=>{
    const v = rawProb[t.key];
    if(!(t.key in smooth)) smooth[t.key]=0;
    smooth[t.key] = EMA_ALPHA*v + (1-EMA_ALPHA)*smooth[t.key];
  });

  // 2) 滑動視窗：放入當前平滑後向量，維持 WINDOW 長度
  ring.push(TARGETS.map(t=>smooth[t.key]));
  if(ring.length > WINDOW) ring.shift();

  // 計算窗口平均
  const avg = Object.fromEntries(TARGETS.map((t,i)=>{
    const mean = ring.reduce((s,vec)=>s+vec[i], 0) / ring.length;
    return [t.key, mean];
  }));

  // 更新條（用窗口平均值）
  TARGETS.forEach(t=>{
    const pct = (avg[t.key]*100).toFixed(1)+'%';
    const bar = $('bar-'+t.key);
    if(bar){ bar.style.width = pct; bar.textContent = pct; }
  });

  // 3) 邊際判斷：Top-1 & Top-2 的差距必須夠大
  const sorted = TARGETS
      .map(t=>({key:t.key, v:avg[t.key]}))
      .sort((a,b)=>b.v-a.v);
  const top1 = sorted[0], top2 = sorted[1];
  const marginOK = (top1.v - top2.v) >= MARGIN;

  // 顯示當前
  const topName = TARGETS.find(x=>x.key===top1.key)?.name || '—';
  $('currentMove').textContent = `${topName}（${(top1.v*100).toFixed(0)}%）`;

  // One-shot 計分（用「窗口平均」+「邊際」+「每式門檻」）
  if(marginOK){
    scoreTick(top1.key, top1.v);
  }else{
    // 邊際不足 → 視為不穩定，重置持續計時
    if(currentKey === top1.key){ currentKey=null; holdStart=0; holdSum=0; holdFrames=0; }
  }
}

// 一次完成 = 100 分（只記第一次）
function scoreTick(topKey, conf){
  const uiTH = Math.max(0.5, Math.min(0.95, parseFloat($('thres').value)||FALLBACK_THRESH));
  const clsTH = PER_CLASS_THRESH[topKey] ?? uiTH;            // 每式客製門檻
  const threshold = Math.max(uiTH, clsTH);                   // 取較嚴格者

  const minHoldMs = Math.max(500, Math.min(5000, (parseFloat($('hold').value)||2)*1000));
  const cooldownMs= Math.max(200, Math.min(3000, (parseFloat($('cool').value)||0.8)*1000));
  const now = performance.now();

  if(done[topKey]) return;        // 該式已完成
  if(now < cooldownUntil) return; // 冷卻中
  if(conf < threshold){           // 低於門檻
    if(currentKey === topKey){ currentKey=null; holdStart=0; holdSum=0; holdFrames=0; }
    return;
  }

  // 穩定持續到時間 → 記 100 分
  if(currentKey !== topKey){
    currentKey = topKey; holdStart = now; holdSum=0; holdFrames=0;
  }
  holdSum += conf; holdFrames++;
  const held = now - holdStart;

  if(held >= minHoldMs){
    done[currentKey] = true;
    score[currentKey] = 100;
    $('status-'+currentKey).textContent = '✅ 已完成';
    $('sc-'+currentKey).textContent = '100';
    flashRow(currentKey);
    recalcTotal();

    cooldownUntil = now + cooldownMs;
    currentKey=null; holdStart=0; holdSum=0; holdFrames=0;
  }
}
</script>
